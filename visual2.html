<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flood Analysis Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input, select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .visual-step-container {
            margin-top: 30px;
            padding: 25px;
            background: #f0f8ff;
            border-radius: 10px;
            border: 3px solid #4CAF50;
            display: none;
        }

        .current-step-title {
            font-size: 1.5em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .step-description {
            text-align: center;
            font-size: 1.1em;
            color: #555;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .step-counter {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            display: inline-block;
            margin-bottom: 10px;
        }

        .highlight-scan {
            box-shadow: 0 0 0 4px #ff9800 !important;
            animation: scanPulse 0.6s ease-in-out;
            transform: scale(1.15);
            z-index: 100;
        }

        .highlight-dry {
            box-shadow: 0 0 0 4px #4CAF50 !important;
            animation: foundPulse 0.5s ease-in-out;
        }

        .highlight-reachable {
            box-shadow: 0 0 0 4px #2196F3 !important;
            animation: reachPulse 0.5s ease-in-out;
        }

        .highlight-rescue {
            box-shadow: 0 0 0 6px #FFC107 !important;
            animation: rescuePulse 1s ease-in-out;
            transform: scale(1.2);
        }

        @keyframes scanPulse {
            0%, 100% { box-shadow: 0 0 0 4px #ff9800; }
            50% { box-shadow: 0 0 0 8px #ff9800; }
        }

        @keyframes foundPulse {
            0%, 100% { box-shadow: 0 0 0 4px #4CAF50; }
            50% { box-shadow: 0 0 0 8px #4CAF50; }
        }

        @keyframes reachPulse {
            0%, 100% { box-shadow: 0 0 0 4px #2196F3; }
            50% { box-shadow: 0 0 0 8px #2196F3; }
        }

        @keyframes rescuePulse {
            0%, 100% { box-shadow: 0 0 0 6px #FFC107; }
            50% { box-shadow: 0 0 0 10px #FFC107; }
        }

        .running-total {
            font-size: 1.3em;
            font-weight: 700;
            color: #e74c3c;
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-top: 15px;
        }

        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .grid-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .grid-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .grid {
            display: grid;
            gap: 4px;
            margin: 0 auto;
            width: fit-content;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 2px solid #34495e;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .cell-water {
            background: linear-gradient(135deg, #2980b9, #6dd5fa);
            color: white;
        }

        .cell-land {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            color: white;
        }

        .cell-rescue {
            background: linear-gradient(135deg, #f2994a, #f2c94c);
            color: white;
        }

        .cell-flooded {
            background: linear-gradient(135deg, #00416a, #799f0c);
            color: white;
            animation: flood 0.5s ease-in-out;
        }

        @keyframes flood {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75em;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .cell:hover .tooltip {
            opacity: 1;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin-top: 30px;
            padding: 25px;
            background: #ecf0f1;
            border-radius: 10px;
        }

        .calculation-steps {
            margin-top: 30px;
            padding: 25px;
            background: #fff3cd;
            border-radius: 10px;
            border-left: 5px solid #ffc107;
        }

        .calculation-steps h3 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .step {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }

        .step-title {
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .step-detail {
            color: #555;
            line-height: 1.6;
            margin: 5px 0;
        }

        .step-result {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            color: #0056b3;
        }

        .highlight-cell {
            box-shadow: 0 0 0 3px #ffc107 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 3px #ffc107; }
            50% { box-shadow: 0 0 0 6px #ffc107; }
        }

        .comparison-side {
            text-align: center;
        }

        .comparison-title {
            font-size: 1.2em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .comparison-stat {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 8px;
        }

        .arrow {
            font-size: 3em;
            color: #e74c3c;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid #34495e;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Flood Analysis System</h1>
        <p class="subtitle">Interactive visualization of DFS-based flood simulation and rescue analysis</p>

        <div class="controls">
            <div class="control-group">
                <label>Grid Size</label>
                <select id="gridSize">
                    <option value="5">5x5</option>
                    <option value="6" selected>6x6</option>
                    <option value="7">7x7</option>
                    <option value="8">8x8</option>
                </select>
            </div>
            <div class="control-group">
                <label>Flood Level</label>
                <input type="number" id="floodLevel" value="3" min="0" max="10">
            </div>
            <div class="control-group">
                <label>Paint Mode</label>
                <select id="paintMode">
                    <option value="1">Land</option>
                    <option value="0">Water</option>
                    <option value="R">Rescue Center</option>
                </select>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn-primary" onclick="generateRandom()">üé≤ Random Map</button>
            <button class="btn-success" onclick="simulateFlood()">üåä Simulate Flood</button>
            <button class="btn-warning" onclick="visualizeStepByStep()" id="visualizeBtn" disabled>üëÅÔ∏è Visual Step-by-Step</button>
            <button class="btn-danger" onclick="reset()">üîÑ Reset</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box cell-water"></div>
                <span>Water</span>
            </div>
            <div class="legend-item">
                <div class="legend-box cell-land"></div>
                <span>Land</span>
            </div>
            <div class="legend-item">
                <div class="legend-box cell-rescue"></div>
                <span>Rescue Center</span>
            </div>
            <div class="legend-item">
                <div class="legend-box cell-flooded"></div>
                <span>Flooded Area</span>
            </div>
        </div>

        <div class="visualization">
            <div class="grid-container">
                <div class="grid-title">üó∫Ô∏è Before Flood</div>
                <div id="beforeGrid" class="grid"></div>
                <div class="stats" id="beforeStats"></div>
            </div>
            <div class="grid-container">
                <div class="grid-title">üåä After Flood</div>
                <div id="afterGrid" class="grid"></div>
                <div class="stats" id="afterStats"></div>
            </div>
        </div>

        <div class="comparison" id="comparison" style="display: none;">
            <div class="comparison-side">
                <div class="comparison-title">Before Flood</div>
                <div class="comparison-stat">Islands: <strong id="beforeIslands">-</strong></div>
                <div class="comparison-stat">Max Area: <strong id="beforeArea">-</strong></div>
                <div class="comparison-stat">Max Perimeter: <strong id="beforePerim">-</strong></div>
            </div>
            <div class="arrow">‚Üí</div>
            <div class="comparison-side">
                <div class="comparison-title">After Flood</div>
                <div class="comparison-stat">Islands: <strong id="afterIslands">-</strong></div>
                <div class="comparison-stat">Max Area: <strong id="afterArea">-</strong></div>
                <div class="comparison-stat">Max Perimeter: <strong id="afterPerim">-</strong></div>
                <div class="comparison-stat" style="background: #e74c3c; color: white;">
                    Isolated Population: <strong id="isolatedPop">-</strong>
                </div>
            </div>
        </div>

        <div class="calculation-steps" id="calculationSteps" style="display: none;">
            <h3>üìä Population Calculation Breakdown</h3>
            
            <div class="step">
                <div class="step-title">Step 1: Calculate Total Dry Population</div>
                <div class="step-detail">
                    Loop through all cells after flood. If cell is '1' (land) or 'R' (rescue center), add its population.
                </div>
                <div class="step-detail" id="dryDetails"></div>
                <div class="step-result">
                    <strong>Total Dry Population = <span id="dryResult">0</span></strong>
                </div>
            </div>

            <div class="step">
                <div class="step-title">Step 2: Calculate Reachable Population</div>
                <div class="step-detail">
                    For each rescue center 'R', use DFS to explore all connected land cells and sum their populations.
                </div>
                <div class="step-detail" id="reachableDetails"></div>
                <div class="step-result">
                    <strong>Reachable Population = <span id="reachableResult">0</span></strong>
                </div>
            </div>

            <div class="step">
                <div class="step-title">Step 3: Calculate Isolated Population</div>
                <div class="step-detail">
                    Subtract reachable population from total dry population.
                </div>
                <div class="step-detail" id="isolatedFormula"></div>
                <div class="step-result" style="background: #ffe7e7;">
                    <strong>Isolated Population = <span id="isolatedResult">0</span></strong><br>
                    <small>These people are on dry land but cannot reach any rescue center!</small>
                </div>
            </div>
        </div>

        <div class="visual-step-container" id="visualStepContainer">
            <div class="current-step-title" id="currentStepTitle">Starting Visualization...</div>
            <div class="step-counter" id="stepCounter">Step 0/0</div>
            <div class="step-description" id="stepDescription">Click the button to start</div>
            <div class="running-total" id="runningTotal"></div>
        </div>
    </div>

    <script>
        let n = 6;
        let grid = [];
        let elevation = [];
        let population = [];
        let afterFloodGrid = [];

        const dir = [[1,0], [-1,0], [0,1], [0,-1]];

        function initializeGrid() {
            n = parseInt(document.getElementById('gridSize').value);
            grid = Array(n).fill().map(() => Array(n).fill('0'));
            elevation = Array(n).fill().map(() => Array(n).fill(0));
            population = Array(n).fill().map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    elevation[i][j] = Math.floor(Math.random() * 8) + 1;
                    population[i][j] = Math.floor(Math.random() * 20) + 5;
                }
            }
            
            renderGrid();
        }

        function renderGrid() {
            const beforeDiv = document.getElementById('beforeGrid');
            const afterDiv = document.getElementById('afterGrid');
            
            beforeDiv.style.gridTemplateColumns = `repeat(${n}, 50px)`;
            afterDiv.style.gridTemplateColumns = `repeat(${n}, 50px)`;
            
            beforeDiv.innerHTML = '';
            afterDiv.innerHTML = '';
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const cell = createCell(i, j, grid[i][j], elevation[i][j], population[i][j]);
                    beforeDiv.appendChild(cell);
                }
            }
            
            document.getElementById('beforeStats').innerHTML = '';
            document.getElementById('afterStats').innerHTML = '';
            document.getElementById('comparison').style.display = 'none';
        }

        function createCell(i, j, type, elev, pop) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            
            if (type === '0') cell.classList.add('cell-water');
            else if (type === '1') cell.classList.add('cell-land');
            else if (type === 'R') cell.classList.add('cell-rescue');
            
            let displayText = type === '0' ? '0' : type === 'R' ? 'R' : '1';
            cell.innerHTML = `
                ${displayText}
                <div class="tooltip">
                    Elev: ${elev}<br>
                    Pop: ${pop}
                </div>
            `;
            
            cell.onclick = () => {
                const mode = document.getElementById('paintMode').value;
                grid[i][j] = mode;
                renderGrid();
            };
            
            return cell;
        }

        function generateRandom() {
            n = parseInt(document.getElementById('gridSize').value);
            grid = Array(n).fill().map(() => Array(n).fill('0'));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const rand = Math.random();
                    if (rand < 0.15) grid[i][j] = '0';
                    else if (rand < 0.85) grid[i][j] = '1';
                    else grid[i][j] = 'R';
                    
                    elevation[i][j] = Math.floor(Math.random() * 8) + 1;
                    population[i][j] = Math.floor(Math.random() * 20) + 5;
                }
            }
            
            renderGrid();
        }

        function DFS_area(i, j, g) {
            if (i < 0 || j < 0 || i >= n || j >= n || g[i][j] === '0') return 0;
            g[i][j] = '0';
            let area = 1;
            for (let d of dir) {
                area += DFS_area(i + d[0], j + d[1], g);
            }
            return area;
        }

        function DFS_perimeter(i, j, g) {
            if (i < 0 || j < 0 || i >= n || j >= n || g[i][j] === '0') return 1;
            if (g[i][j] === '2') return 0;
            g[i][j] = '2';
            let perim = 0;
            for (let d of dir) {
                perim += DFS_perimeter(i + d[0], j + d[1], g);
            }
            return perim;
        }

        function DFS_reach(i, j, g, pop) {
            if (i < 0 || j < 0 || i >= n || j >= n || g[i][j] === '0') return 0;
            g[i][j] = '0';
            let total = pop[i][j];
            for (let d of dir) {
                total += DFS_reach(i + d[0], j + d[1], g, pop);
            }
            return total;
        }

        function analyzeGrid(g) {
            let tempGrid = g.map(row => [...row]);
            let islands = 0, maxArea = 0;
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (tempGrid[i][j] === '1' || tempGrid[i][j] === 'R') {
                        islands++;
                        let area = DFS_area(i, j, tempGrid);
                        maxArea = Math.max(maxArea, area);
                    }
                }
            }
            
            tempGrid = g.map(row => [...row]);
            let maxPerimeter = 0;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (tempGrid[i][j] === '1' || tempGrid[i][j] === 'R') {
                        let perim = DFS_perimeter(i, j, tempGrid);
                        maxPerimeter = Math.max(maxPerimeter, perim);
                    }
                }
            }
            
            return { islands, maxArea, maxPerimeter };
        }

        function simulateFlood() {
            const floodLevel = parseInt(document.getElementById('floodLevel').value);
            
            const beforeStats = analyzeGrid(grid);
            
            afterFloodGrid = grid.map((row, i) => 
                row.map((cell, j) => 
                    (cell !== '0' && elevation[i][j] <= floodLevel) ? '0' : cell
                )
            );
            
            const afterDiv = document.getElementById('afterGrid');
            afterDiv.innerHTML = '';
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const cell = createCell(i, j, afterFloodGrid[i][j], elevation[i][j], population[i][j]);
                    if (grid[i][j] !== '0' && afterFloodGrid[i][j] === '0') {
                        cell.classList.remove('cell-land', 'cell-rescue');
                        cell.classList.add('cell-flooded');
                    }
                    afterDiv.appendChild(cell);
                }
            }
            
            const afterStats = analyzeGrid(afterFloodGrid);
            
            // STEP 1: Calculate Total Dry Population
            let totalDryPop = 0;
            let dryCells = [];
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (afterFloodGrid[i][j] !== '0') {
                        totalDryPop += population[i][j];
                        dryCells.push({i, j, pop: population[i][j], type: afterFloodGrid[i][j]});
                    }
                }
            }
            
            // STEP 2: Calculate Reachable Population
            let reachablePop = 0;
            let reachCopy = afterFloodGrid.map(row => [...row]);
            let rescueCenters = [];
            let reachableCells = [];
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (reachCopy[i][j] === 'R') {
                        rescueCenters.push({i, j});
                        let reached = DFS_reach_track(i, j, reachCopy, population, reachableCells);
                        reachablePop += reached;
                    }
                }
            }
            
            // STEP 3: Calculate Isolated Population
            const isolatedPop = totalDryPop - reachablePop;
            
            displayStats(beforeStats, afterStats, totalDryPop, reachablePop, isolatedPop);
            displayCalculationSteps(dryCells, rescueCenters, reachableCells, totalDryPop, reachablePop, isolatedPop);
            
            // Enable visual step-by-step button
            document.getElementById('visualizeBtn').disabled = false;
        }

        function DFS_reach_track(i, j, g, pop, trackList) {
            if (i < 0 || j < 0 || i >= n || j >= n || g[i][j] === '0') return 0;
            g[i][j] = '0';
            trackList.push({i, j, pop: pop[i][j]});
            let total = pop[i][j];
            for (let d of dir) {
                total += DFS_reach_track(i + d[0], j + d[1], g, pop, trackList);
            }
            return total;
        }

        function displayCalculationSteps(dryCells, rescueCenters, reachableCells, totalDry, reachable, isolated) {
            // Step 1 details
            let dryDetail = `Found ${dryCells.length} dry cells: `;
            dryDetail += dryCells.map(c => `(${c.i},${c.j})[${c.type}:${c.pop}]`).join(', ');
            document.getElementById('dryDetails').textContent = dryDetail;
            document.getElementById('dryResult').textContent = totalDry;
            
            // Step 2 details
            let reachDetail = `Found ${rescueCenters.length} rescue center(s). `;
            if (rescueCenters.length > 0) {
                reachDetail += `Starting DFS from: ${rescueCenters.map(c => `(${c.i},${c.j})`).join(', ')}. `;
                reachDetail += `Reached ${reachableCells.length} cells with total population: `;
                reachDetail += reachableCells.map(c => `(${c.i},${c.j})[${c.pop}]`).join(', ');
            } else {
                reachDetail += 'No rescue centers available, so reachable population = 0.';
            }
            document.getElementById('reachableDetails').textContent = reachDetail;
            document.getElementById('reachableResult').textContent = reachable;
            
            // Step 3 details
            document.getElementById('isolatedFormula').textContent = 
                `${totalDry} (Total Dry) - ${reachable} (Reachable) = ${isolated}`;
            document.getElementById('isolatedResult').textContent = isolated;
            
            document.getElementById('calculationSteps').style.display = 'block';
        }

        function displayStats(before, after, totalDry, reachable, isolated) {
            document.getElementById('beforeIslands').textContent = before.islands;
            document.getElementById('beforeArea').textContent = before.maxArea;
            document.getElementById('beforePerim').textContent = before.maxPerimeter;
            
            document.getElementById('afterIslands').textContent = after.islands;
            document.getElementById('afterArea').textContent = after.maxArea;
            document.getElementById('afterPerim').textContent = after.maxPerimeter;
            document.getElementById('isolatedPop').textContent = isolated;
            
            document.getElementById('comparison').style.display = 'grid';
            
            const afterStatsDiv = document.getElementById('afterStats');
            afterStatsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Dry Population</div>
                    <div class="stat-value">${totalDry}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);">
                    <div class="stat-label">Reachable by Rescue</div>
                    <div class="stat-value">${reachable}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);">
                    <div class="stat-label">‚ö†Ô∏è Isolated</div>
                    <div class="stat-value">${isolated}</div>
                </div>
            `;
        }

        function reset() {
            initializeGrid();
            document.getElementById('visualizeBtn').disabled = true;
            document.getElementById('visualStepContainer').style.display = 'none';
        }

        // Visual step-by-step animation
        let visualSteps = [];
        let currentStepIndex = 0;
        let isAnimating = false;

        async function visualizeStepByStep() {
            if (isAnimating) return;
            isAnimating = true;
            
            document.getElementById('visualStepContainer').style.display = 'block';
            document.getElementById('calculationSteps').style.display = 'none';
            
            visualSteps = [];
            currentStepIndex = 0;
            
            // Prepare all steps
            prepareVisualSteps();
            
            // Animate through steps
            for (let i = 0; i < visualSteps.length; i++) {
                currentStepIndex = i;
                await executeVisualStep(visualSteps[i]);
                await sleep(800);
            }
            
            isAnimating = false;
            document.getElementById('currentStepTitle').textContent = '‚úÖ Calculation Complete!';
        }

        function prepareVisualSteps() {
            let stepNum = 1;
            
            // Phase 1: Scan for dry cells
            visualSteps.push({
                phase: 1,
                type: 'phase_start',
                title: 'üîç Phase 1: Finding Dry Population',
                description: 'Scanning all cells after flood to find dry land...',
                stepNum: stepNum++
            });
            
            let runningDryTotal = 0;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    visualSteps.push({
                        phase: 1,
                        type: 'scan',
                        i, j,
                        cell: afterFloodGrid[i][j],
                        pop: population[i][j],
                        title: `Checking cell (${i},${j})`,
                        stepNum: stepNum++
                    });
                    
                    if (afterFloodGrid[i][j] !== '0') {
                        runningDryTotal += population[i][j];
                        visualSteps.push({
                            phase: 1,
                            type: 'found_dry',
                            i, j,
                            pop: population[i][j],
                            total: runningDryTotal,
                            title: `Found dry cell at (${i},${j})!`,
                            description: `Cell type: ${afterFloodGrid[i][j]}, Population: ${population[i][j]}`,
                            stepNum: stepNum++
                        });
                    }
                }
            }
            
            visualSteps.push({
                phase: 1,
                type: 'phase_end',
                total: runningDryTotal,
                title: '‚úÖ Phase 1 Complete',
                description: `Total Dry Population = ${runningDryTotal}`,
                stepNum: stepNum++
            });
            
            // Phase 2: Find reachable from rescue centers
            visualSteps.push({
                phase: 2,
                type: 'phase_start',
                title: 'üöÅ Phase 2: Finding Reachable Population',
                description: 'Starting DFS from rescue centers...',
                stepNum: stepNum++
            });
            
            let reachCopy = afterFloodGrid.map(row => [...row]);
            let runningReachTotal = 0;
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (reachCopy[i][j] === 'R') {
                        visualSteps.push({
                            phase: 2,
                            type: 'found_rescue',
                            i, j,
                            title: `Found Rescue Center at (${i},${j})`,
                            description: 'Starting DFS exploration from here...',
                            stepNum: stepNum++
                        });
                        
                        let reachedFromThis = [];
                        DFS_visual_track(i, j, reachCopy, population, reachedFromThis, visualSteps, stepNum);
                        
                        for (let cell of reachedFromThis) {
                            runningReachTotal += cell.pop;
                            stepNum++;
                        }
                    }
                }
            }
            
            visualSteps.push({
                phase: 2,
                type: 'phase_end',
                total: runningReachTotal,
                title: '‚úÖ Phase 2 Complete',
                description: `Reachable Population = ${runningReachTotal}`,
                stepNum: stepNum++
            });
            
            // Phase 3: Calculate isolated
            const isolated = runningDryTotal - runningReachTotal;
            visualSteps.push({
                phase: 3,
                type: 'phase_start',
                title: '‚ö†Ô∏è Phase 3: Calculate Isolated Population',
                description: `${runningDryTotal} (Dry) - ${runningReachTotal} (Reachable) = ${isolated}`,
                total: isolated,
                stepNum: stepNum++
            });
        }

        function DFS_visual_track(i, j, g, pop, trackList, steps, stepNum) {
            if (i < 0 || j < 0 || i >= n || j >= n || g[i][j] === '0') return 0;
            
            const cellPop = pop[i][j];
            g[i][j] = '0';
            
            steps.push({
                phase: 2,
                type: 'dfs_reach',
                i, j,
                pop: cellPop,
                title: `DFS reached (${i},${j})`,
                description: `Adding population: ${cellPop}`,
                stepNum: stepNum++
            });
            
            trackList.push({i, j, pop: cellPop});
            
            let total = cellPop;
            for (let d of dir) {
                total += DFS_visual_track(i + d[0], j + d[1], g, pop, trackList, steps, stepNum);
            }
            return total;
        }

        async function executeVisualStep(step) {
            // Clear previous highlights
            const afterCells = document.querySelectorAll('#afterGrid .cell');
            afterCells.forEach(cell => {
                cell.classList.remove('highlight-scan', 'highlight-dry', 'highlight-reachable', 'highlight-rescue');
            });
            
            document.getElementById('stepCounter').textContent = `Step ${step.stepNum}/${visualSteps.length}`;
            document.getElementById('currentStepTitle').textContent = step.title;
            document.getElementById('stepDescription').textContent = step.description || '';
            
            if (step.type === 'scan') {
                const cellIndex = step.i * n + step.j;
                afterCells[cellIndex].classList.add('highlight-scan');
                document.getElementById('stepDescription').textContent = 
                    `Checking (${step.i},${step.j}): Type=${step.cell}, Pop=${step.pop}`;
            }
            
            if (step.type === 'found_dry') {
                const cellIndex = step.i * n + step.j;
                afterCells[cellIndex].classList.add('highlight-dry');
                document.getElementById('runningTotal').textContent = 
                    `Running Dry Total: ${step.total}`;
            }
            
            if (step.type === 'found_rescue') {
                const cellIndex = step.i * n + step.j;
                afterCells[cellIndex].classList.add('highlight-rescue');
            }
            
            if (step.type === 'dfs_reach') {
                const cellIndex = step.i * n + step.j;
                afterCells[cellIndex].classList.add('highlight-reachable');
            }
            
            if (step.type === 'phase_end') {
                document.getElementById('runningTotal').textContent = 
                    `Phase ${step.phase} Result: ${step.total}`;
            }
            
            if (step.phase === 3) {
                document.getElementById('runningTotal').textContent = 
                    `üö® Isolated Population: ${step.total} people cannot reach rescue!`;
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.getElementById('gridSize').addEventListener('change', initializeGrid);
        
        initializeGrid();
        generateRandom();
    </script>
</body>
</html>